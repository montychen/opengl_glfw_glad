* WebGL和画布canvas
WebGL使用在HTML5中新引入的<canvas>标签来定义绘图区域；传统的<img>标签只能用来显示图片，不能进行实时绘制和渲染；<canvas>允许Javascript动态的绘制图形，如果没有WebGL, Javascript只能在<canvas>绘制二维图形，有了WebGL,就可以在上面绘制三维图形了。
#+ATTR_latex: :width 800   #+ATTR_HTML: :width 800  #+ATTR_ORG: :width 800
[[file:webgl/webgl_opengl.png]]

- 2011年3月发布基于OpenGL ES 2.0的 WebGL 1.0;  2017年1月发布基于OpenGL ES 3.0的WebGL 2.0。
- 截止2019年12月，iOS和Android上的浏览器都已经支持WebGL 1.0, 但都还不支持WebGL 2.0。 PC上，Chrome和firefox都支持WebGL 2.0, safari只支持WebGL 1.0
- 在浏览器输入 https://webglreport.com/ 可查看该浏览器对WebGL的支持情况。
- WebGL渲染过程
#+ATTR_latex: :width 800   #+ATTR_HTML: :width 800  #+ATTR_ORG: :width 800
[[file:webgl/webgl_pipeline.png]]

* 在canvas绘图的4个步骤
1. 在html中定义canvas，并用id属性为其指定唯一标识符；加载JS文件，同时在<body>的onload属性指定JS执行的入口函数
#+begin_src html
<!DOCTYPE html>
<html lang="en">
  <head> <meta charset="utf-8" /> <title>Draw a blue rectangle (canvas version)</title>  </head>

  <body onload="main()"> <!-- 指定执行JS的入口函数 -->
    <canvas id="webgl" width="400" height="400">  Please use a browser that supports "canvas" </canvas> <!-- 定义canvas，并用id属性为其指定唯一标识符, 也指定了画布的宽高； -->
    <script src="DrawRectangle.js"></script>       <!-- 加载JS文件 -->
  </body>
</html>
#+end_src

2. 通过id标识符，获取<canvas>元素
3. 请求绘图上下文context
4. 通过绘图上下文调用绘图函数

*** 例子1：清空绘图背景色

#+begin_src javascript
// DrawTriangle.js (c) 2012 matsuda
function main() {               // JS函数入口
    var canvas = document.getElementById('webgl'); // 通过id标识符，获取<canvas>元素
    if (!canvas) {
        console.log('Failed to retrieve the <canvas> element');
        return false;
    }

    var gl = canvas.getContext('webgl'); // 用webgl或expeimental-webgl请求WebGL绘图上下文。

    // 用指定的黑色，清空绘图区域
    gl.clearColor(0.0, 0.0, 0.0, 1.0); // 指定清空画布的颜色为黑色。 颜色的取值从0.0到1.0。前面3个参数分别是rgb的值。最后一个参数是透明度a，它的取值在0.0透明---到1.0不透明之间。
    gl.clear(gl.COLOR_BUFFER_BIT);     // 用上面设置的clearColor清空绘图区域。opengl有多个缓冲区：颜色缓冲区COLOR_BUFFER_BIT、深度缓冲区DEPTH_BUFFER_BIT、模版缓冲区STENCIL_BUFFER_BIT。清空绘图区域实际上是清空颜色缓冲区color buffer， 所以这里传递的参数是COLOR_BUFFER_BIT
}
#+end_src

*** 例子2: 绘制一个点
#+begin_src javascript
// HelloPoint1.js (c) 2012 matsuda
// Vertex shader program
var VSHADER_SOURCE =
    'void main() {\n' +
    '  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n' + // Set the vertex coordinates of the point
    '  gl_PointSize = 10.0;\n' +                    // Set the point size
    '}\n';

// Fragment shader program
var FSHADER_SOURCE =
    'void main() {\n' +
    '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n' + // Set the point color
    '}\n';

function main() {
    // Retrieve <canvas> element
    var canvas = document.getElementById('webgl');

    // Get the rendering context for WebGL
    var gl = getWebGLContext(canvas);
    if (!gl) {
        console.log('Failed to get the rendering context for WebGL');
        return;
    }

    // Initialize shaders
    if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
        console.log('Failed to intialize shaders.');
        return;
    }

    // Specify the color for clearing <canvas>
    gl.clearColor(0.0, 0.0, 0.0, 1.0);

    // Clear <canvas>
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Draw a point
    gl.drawArrays(gl.POINTS, 0, 1);
}
#+end_src

** canvas的坐标
- 原点（0，0）在左上角， x轴正向朝右， y轴正向朝下。上例定义的canvas宽高（400，400）， 在其中绘制的矩形fillRect(120, 10, 150, 150)如下图所示：

#+ATTR_latex: :width 500   #+ATTR_HTML: :width 500  #+ATTR_ORG: :width 500
[[file:webgl/webgl_coord.png]]
