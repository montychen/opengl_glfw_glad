* WebGL和画布canvas
WebGL使用在HTML5中新引入的<canvas>标签来定义绘图区域；传统的<img>标签只能用来显示图片，不能进行实时绘制和渲染；<canvas>允许Javascript动态的绘制图形，如果没有WebGL, Javascript只能在<canvas>绘制二维图形，有了WebGL,就可以在上面绘制三维图形了。
#+ATTR_latex: :width 800   #+ATTR_HTML: :width 800  #+ATTR_ORG: :width 800
[[file:webgl/webgl_opengl.png]]

- 2011年3月发布基于OpenGL ES 2.0的 WebGL 1.0;  2017年1月发布基于OpenGL ES 3.0的WebGL 2.0。
- 截止2019年12月，iOS和Android上的浏览器都已经支持WebGL 1.0, 但都还不支持WebGL 2.0。 PC上，Chrome和firefox都支持WebGL 2.0, safari只支持WebGL 1.0
- 在浏览器输入 https://webglreport.com/ 可查看该浏览器对WebGL的支持情况。
- WebGL渲染过程
#+ATTR_latex: :width 800   #+ATTR_HTML: :width 800  #+ATTR_ORG: :width 800
[[file:webgl/webgl_pipeline.png]]

* 在canvas绘图的4个步骤
** 1、在html中定义canvas，并用id属性为其指定唯一标识符；加载JS文件，同时在<body>的onload属性指定JS执行的入口函数
#+begin_src html
<!DOCTYPE html>
<html lang="en">
  <head> <meta charset="utf-8" /> <title>Draw a blue rectangle (canvas version)</title>  </head>

  <body onload="main()"> <!-- 指定执行JS的入口函数 -->
    <canvas id="webgl" width="400" height="400">  Please use a browser that supports "canvas" </canvas> <!-- 定义canvas，并用id属性为其指定唯一标识符, 也指定了画布的宽高； -->
    <script src="DrawRectangle.js"></script>       <!-- 加载JS文件 -->
  </body>
</html>
#+end_src

** 2、通过id标识符，获取<canvas>元素
** 3、请求绘图上下文context
** 4、通过绘图上下文调用绘图函数

** 例子1：清空绘图背景色

#+begin_src javascript
// DrawTriangle.js (c) 2012 matsuda
function main() {               // JS函数入口
    var canvas = document.getElementById('webgl'); // 通过id标识符，获取<canvas>元素
    if (!canvas) {
        console.log('Failed to retrieve the <canvas> element');
        return false;
    }

    var gl = canvas.getContext('webgl'); // 用webgl或expeimental-webgl请求WebGL绘图上下文。

    // 用指定的黑色，清空绘图区域
    gl.clearColor(0.0, 0.0, 0.0, 1.0); // 指定清空画布的颜色为黑色。 颜色的取值从0.0到1.0。前面3个参数分别是rgb的值。最后一个参数是透明度a，它的取值在0.0透明---到1.0不透明之间。
    gl.clear(gl.COLOR_BUFFER_BIT);     // 用上面设置的clearColor清空绘图区域。opengl有多个缓冲区：颜色缓冲区COLOR_BUFFER_BIT、深度缓冲区DEPTH_BUFFER_BIT、模版缓冲区STENCIL_BUFFER_BIT。清空绘图区域实际上是清空颜色缓冲区color buffer， 所以这里传递的参数是COLOR_BUFFER_BIT
}
#+end_src

** 例子2: 绘制一个点
#+begin_src javascript
// 顶点着色器。顶点指的是二维或三维空间总的一个点。
var VSHADER_SOURCE =
    'void main() {\n' +
    '  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n' + // gl_Position是内置变量，用来表示一个顶点的位置坐标。
    '  gl_PointSize = 10.0;\n' +                    // gl_PointSize也是内置变量，用来表示点的大小： 这里把每个点设为10个像素的大小
    '}\n';

// 片元着色器的作用就是处理片元，使其显示在屏幕上。 片元指的是显示在屏幕上的一个像素，包括像素的位置、颜色和其它信息。
var FSHADER_SOURCE =
    'void main() {\n' +
    '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n' + // gl_FragColor是片元着色器唯一的内置变量，它控制这像素在屏幕上的最终颜色RGBA，这里设为红色
    '}\n';

function main() {
    var canvas = document.getElementById('webgl'); // 获取canvas元素

    var gl = getWebGLContext(canvas); // 获取webgl的绘图上下文
    if (!gl) {
        console.log('Failed to get the rendering context for WebGL');
        return;
    }

    if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) { // 初始化着色器
        console.log('Failed to intialize shaders.');
        return;
    }

    // 用指定的黑色，清空绘图区域
    gl.clearColor(0.0, 0.0, 0.0, 1.0); // 指定清空画布的颜色为黑色。 颜色的取值从0.0到1.0。前面3个参数分别是rgb的值。最后一个参数是透明度a，它的取值在0.0透明---到1.0不透明之间。
    gl.clear(gl.COLOR_BUFFER_BIT);     // 用上面设置的clearColor清空绘图区域。opengl有多个缓冲区：颜色缓冲区COLOR_BUFFER_BIT、深度缓冲区DEPTH_BUFFER_BIT、模版缓冲区STENCIL_BUFFER_BIT。清空绘图区域实际上是清空颜色缓冲区color buffer， 所以这里传递的参数是COLOR_BUFFER_BIT

    // drawArrays(mode, first, count) 触发着色器开始执行：先逐顶点的执行顶点着色器vertex shader...再逐片元的执行片元着色器fragment shader。
    // count被设为1表示只绘制一个点，所以drawArrays触发顶点着色器执行1次：它将vec4(0.0, 0.0, 0.0, 1.0)赋值给gl_Position，将值10.0赋给gl_PointSize.
    // 一旦顶点着色器执行完后，片元着色器就开始执行，调用main()函数：将颜色值红色 vec4(1.0, 0.0, 0.0, 1.0)赋给gl_FragColor
    // 最后一个 红色的 10个像素打的点 就被绘制在了(0.0, 0.0, 0.0, 1.0）处，也就是canvas的中间。
    gl.drawArrays(gl.POINTS, 0, 1); // gl.POINTS表示绘制点; 0 表示从第一个顶点开始绘制； 1 表示只有一个顶点。
}
#+end_src


* WebGL坐标
** canvas的坐标
- 原点（0，0）在左上角， x轴正向朝右， y轴正向朝下。例如：定义的canvas宽高（400，400）， 在用如下代码绘制的矩形fillRect(120, 10, 150, 150)，效果如下图所示：
#+begin_src javascript
ctx.fillStyle = 'rgba(0, 0, 255, 1.0)'; // Set color to blue
ctx.fillRect(120, 10, 150, 150);        // Fill a rectangle with the color
#+end_src
#+ATTR_latex: :width 500   #+ATTR_HTML: :width 500  #+ATTR_ORG: :width 500
[[file:webgl/canvas_coord.png]]

** WebGL/OpenGL坐标 也叫 右手坐标系(Right-handed Coordinate System)
- 当我们看向屏幕，原点（0.0，0.0，0.0）在屏幕的中间，X轴正向朝右， Y轴正向朝上，Z轴垂直于屏幕正向朝外（从屏幕指向你的后面）。
 
#+ATTR_latex: :width 800   #+ATTR_HTML: :width 800  #+ATTR_ORG: :width 800
[[file:webgl/webgl_coord.png]]

* 从程序传递数据给着色器：attribute变量 和 uniform变量
- attribute变量：是一种GLSL ES变量, 被用来从app向顶点着色器传递数据。只有顶点着色器vertex shader能使用它，所以一般用来传递和顶点相关的数据。在顶点着色器里，必须要把attribute变量声明为一个全局变量。
- uniform变量：传输的是那些对 所有顶点都相同 或者和 顶点无关的数据。
** 例子： 使用attribute变量，传递顶点坐标给顶点着色器
#+begin_src javascript
// Vertex shader program
var VSHADER_SOURCE =
    'attribute vec4 a_Position;\n' + // - attribute变量：被用来从app向顶点着色器传递数据。只有顶点着色器vertex shader能使用它，所以一般用来传递和顶点相关的数据。在顶点着色器里，必须把attribute变量声明为全局变量。

    'void main() {\n' +
    '  gl_Position = a_Position;\n' + // 通过attribute变量， 把顶底坐标值赋给 gl_Position。所以只要在app里动态调整attribute变量的值，就可以修改顶点着色器的坐标。
    '  gl_PointSize = 10.0;\n' +
    '}\n';

// Fragment shader program
var FSHADER_SOURCE =
    'void main() {\n' +
    '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n' +
    '}\n';

function main() {
    var canvas = document.getElementById('webgl');

    var gl = getWebGLContext(canvas);
    if (!gl) {
        console.log('Failed to get the rendering context for WebGL');
        return;
    }

    if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
        console.log('Failed to intialize shaders.');
        return;
    }

    var a_Position = gl.getAttribLocation(gl.program, 'a_Position'); // 获取attribute变量的存储位置
    if (a_Position < 0) {
        console.log('Failed to get the storage location of a_Position');
        return;
    }

    gl.vertexAttrib3f(a_Position, 0.0, -0.5, 0.0); // 给顶点着色器的attribute变量赋值

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.POINTS, 0, 1);
}
#+end_src
