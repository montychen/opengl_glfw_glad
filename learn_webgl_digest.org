* WebGL和画布canvas
WebGL使用在HTML5中新引入的<canvas>标签来定义绘图区域；传统的<img>标签只能用来显示图片，不能进行实时绘制和渲染；<canvas>允许Javascript动态的绘制图形，如果没有WebGL, Javascript只能在<canvas>绘制二维图形，有了WebGL,就可以在上面绘制三维图形了。
#+ATTR_latex: :width 800   #+ATTR_HTML: :width 800  #+ATTR_ORG: :width 800
[[file:webgl/webgl_opengl.png]]

- 2011年3月发布基于OpenGL ES 2.0的 WebGL 1.0;  2017年1月发布基于OpenGL ES 3.0的WebGL 2.0。
- 截止2019年12月，iOS和Android上的浏览器都已经支持WebGL 1.0, 但都还不支持WebGL 2.0。 PC上，Chrome和firefox都支持WebGL 2.0, safari只支持WebGL 1.0
- 在浏览器输入 https://webglreport.com/ 可查看该浏览器对WebGL的支持情况。
- WebGL渲染过程
#+ATTR_latex: :width 800   #+ATTR_HTML: :width 800  #+ATTR_ORG: :width 800
[[file:webgl/webgl_pipeline.png]]

* 在canvas绘图的4个步骤
** 1、在html中定义canvas，并用id属性为其指定唯一标识符；加载JS文件，同时在<body>的onload属性指定JS执行的入口函数
#+begin_src html
<!DOCTYPE html>
<html lang="en">
  <head> <meta charset="utf-8" /> <title>Draw a blue rectangle (canvas version)</title>  </head>

  <body onload="main()"> <!-- 指定执行JS的入口函数 -->
    <canvas id="webgl" width="400" height="400">  Please use a browser that supports "canvas" </canvas> <!-- 定义canvas，并用id属性为其指定唯一标识符, 也指定了画布的宽高； -->
    <script src="DrawRectangle.js"></script>       <!-- 加载JS文件 -->
  </body>
</html>
#+end_src

** 2、通过id标识符，获取<canvas>元素
** 3、请求绘图上下文context
** 4、通过绘图上下文调用绘图函数

** 例子1：清空绘图背景色

#+begin_src javascript
// DrawTriangle.js (c) 2012 matsuda
function main() {               // JS函数入口
    var canvas = document.getElementById('webgl'); // 通过id标识符，获取<canvas>元素
    if (!canvas) {
        console.log('Failed to retrieve the <canvas> element');
        return false;
    }

    var gl = canvas.getContext('webgl'); // 用webgl或expeimental-webgl请求WebGL绘图上下文。

    // 用指定的黑色，清空绘图区域
    gl.clearColor(0.0, 0.0, 0.0, 1.0); // 指定清空画布的颜色为黑色。 颜色的取值从0.0到1.0。前面3个参数分别是rgb的值。最后一个参数是透明度a，它的取值在0.0透明---到1.0不透明之间。
    gl.clear(gl.COLOR_BUFFER_BIT);     // 用上面设置的clearColor清空绘图区域。opengl有多个缓冲区：颜色缓冲区COLOR_BUFFER_BIT、深度缓冲区DEPTH_BUFFER_BIT、模版缓冲区STENCIL_BUFFER_BIT。清空绘图区域实际上是清空颜色缓冲区color buffer， 所以这里传递的参数是COLOR_BUFFER_BIT
}
#+end_src

** 例子2: 绘制一个点
#+begin_src javascript
// vertex shader顶点着色器进行的是逐顶点的操作。顶点指的是二维或三维空间总的一个点的位置坐标。
var VSHADER_SOURCE =
    'void main() {\n' +
    '  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n' + // gl_Position是内置变量，用来表示一个顶点的位置坐标。
    '  gl_PointSize = 10.0;\n' +                    // gl_PointSize也是内置变量，用来表示点的大小： 这里把每个点设为10个像素的大小
    '}\n';

// fragment shader片元着色器的作用就是处理片元，使其显示在屏幕上，它进行的也是逐片元的操作。 片元指的是显示在屏幕上的一个像素，包括像素的位置、颜色和其它信息。
var FSHADER_SOURCE =
    'void main() {\n' +
    '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n' + // gl_FragColor是片元着色器唯一的内置变量，它控制这像素在屏幕上的最终颜色RGBA，这里设为红色
    '}\n';

function main() {
    var canvas = document.getElementById('webgl'); // 获取canvas元素

    var gl = getWebGLContext(canvas); // 获取webgl的绘图上下文
    if (!gl) {
        console.log('Failed to get the rendering context for WebGL');
        return;
    }

    if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) { // 初始化着色器
        console.log('Failed to intialize shaders.');
        return;
    }

    // 用指定的黑色，清空绘图区域
    gl.clearColor(0.0, 0.0, 0.0, 1.0); // 指定清空画布的颜色为黑色。 颜色的取值从0.0到1.0。前面3个参数分别是rgb的值。最后一个参数是透明度a，它的取值在0.0透明---到1.0不透明之间。
    gl.clear(gl.COLOR_BUFFER_BIT);     // 用上面设置的clearColor清空绘图区域。opengl有多个缓冲区：颜色缓冲区COLOR_BUFFER_BIT、深度缓冲区DEPTH_BUFFER_BIT、模版缓冲区STENCIL_BUFFER_BIT。清空绘图区域实际上是清空颜色缓冲区color buffer， 所以这里传递的参数是COLOR_BUFFER_BIT

    // drawArrays(mode, first, count) 触发着色器开始执行：先逐顶点的执行顶点着色器vertex shader...再逐片元的执行片元着色器fragment shader。
    // count被设为1表示只绘制一个点，所以drawArrays触发顶点着色器执行1次：它将vec4(0.0, 0.0, 0.0, 1.0)赋值给gl_Position，将值10.0赋给gl_PointSize.
    // 一旦顶点着色器执行完后，片元着色器就开始执行，调用main()函数：将颜色值红色 vec4(1.0, 0.0, 0.0, 1.0)赋给gl_FragColor
    // 最后一个 红色的 10个像素打的点 就被绘制在了(0.0, 0.0, 0.0, 1.0）处，也就是canvas的中间。
    gl.drawArrays(gl.POINTS, 0, 1); // gl.POINTS表示绘制点; 0 表示从第一个顶点开始绘制； 1 表示只有一个顶点，所以drawArrays触发顶点着色器执行1次
}
#+end_src


* WebGL坐标
** canvas的坐标
- 原点（0，0）在左上角， x轴正向朝右， y轴正向朝下。例如：定义的canvas宽高（400，400）， 在用如下代码绘制的矩形fillRect(120, 10, 150, 150)，效果如下图所示：
#+begin_src javascript
ctx.fillStyle = 'rgba(0, 0, 255, 1.0)'; // Set color to blue
ctx.fillRect(120, 10, 150, 150);        // Fill a rectangle with the color
#+end_src
#+ATTR_latex: :width 500   #+ATTR_HTML: :width 500  #+ATTR_ORG: :width 500
[[file:webgl/canvas_coord.png]]

** 浏览器客户区坐标 client area
- 在浏览器，鼠标点击位置的坐标，是一个基于浏览器客户区的坐标值（client area）。它和canvas的坐标关系如下图所示：
#+ATTR_latex: :width 800   #+ATTR_HTML: :width 800  #+ATTR_ORG: :width 800
[[file:webgl/browser_coord.png]]

** WebGL/OpenGL坐标 也叫 右手坐标系(Right-handed Coordinate System)
- 当我们看向屏幕，原点（0.0，0.0，0.0）在屏幕的中间，X轴正向朝右， Y轴正向朝上，Z轴垂直于屏幕正向朝外（从屏幕指向你的后面）。

#+ATTR_latex: :width 800   #+ATTR_HTML: :width 800  #+ATTR_ORG: :width 800
[[file:webgl/webgl_coord.png]]


* 从程序传递数据给着色器：attribute变量、uniform变量和varying变量
** attribute变量
- attribute变量：只能在vertex shader中使用的变量, 一般用来表示一些顶点的数据如：顶点坐标，纹理坐标，顶点颜色等。
- 在顶点着色器里，必须要把attribute变量声明为一个全局变量。
- 应用程序通过glGetAttribLocation函数来获得某个attribute 变量存储位置， 然后通过glVertexAttrib**函数赋值。

** uniform变量
- 用来向vertex或fragment着色器中传递不变的数据，就像C语言里的const常量，它不能被shader程序修改（shader只能用，不能改）。如果想从app传递数据给片元着色器，只就要使用uniform变量。
- 如果uniform变量在vertex和fragment着色器两者之间的声明方式完全一样，则它可以在vertex和fragment共享使用。相当于一个被vertex和fragment shader共享的全局变量
- uniform变量一般用来表示：变换矩阵，材质，光照参数和颜色等信息。
- 应用程序通过glGetUniformLocation函数函数来获得存储位置，再通过函数glUniform**（）函数赋值

** varying变量
- varying变量是vertex和fragment shader之间做数据传递用的。一般vertex shader修改varying变量的值，然后fragment shader使用该varying变量的值。因此varying变量在vertex和fragment shader二者之间的声明必须是一致的。
- 应用程序不能访问或使用此变量。

** 例子：绘制一个点， 用attribute变量，传递一个顶点坐标给顶点着色器
#+begin_src javascript
// Vertex shader program
var VSHADER_SOURCE =
    'attribute vec4 a_Position;\n' + // - attribute变量：被用来从app向顶点着色器传递数据。只有顶点着色器vertex shader能使用它，所以一般用来传递和顶点相关的数据。在顶点着色器里，必须把attribute变量声明为全局变量。

    'void main() {\n' +
    '  gl_Position = a_Position;\n' + // 通过attribute变量， 把顶底坐标值赋给 gl_Position。所以只要在app里动态调整attribute变量的值，就可以修改顶点着色器的坐标。
    '  gl_PointSize = 10.0;\n' +
    '}\n';

// Fragment shader program
var FSHADER_SOURCE =
    'void main() {\n' +
    '  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n' +
    '}\n';

function main() {
    var canvas = document.getElementById('webgl');

    var gl = getWebGLContext(canvas);
    if (!gl) {
        console.log('Failed to get the rendering context for WebGL');
        return;
    }

    if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
        console.log('Failed to intialize shaders.');
        return;
    }

    var a_Position = gl.getAttribLocation(gl.program, 'a_Position'); // 获取attribute变量的存储位置
    if (a_Position < 0) {
        console.log('Failed to get the storage location of a_Position');
        return;
    }

    gl.vertexAttrib3f(a_Position, 0.0, -0.5, 0.0); // 给顶点着色器的attribute变量赋值

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);     // 用上面设置的clearColor清空绘图区域。opengl有多个缓冲区：颜色缓冲区COLOR_BUFFER_BIT、深度缓冲区DEPTH_BUFFER_BIT、模版缓冲区STENCIL_BUFFER_BIT。清空绘图区域实际上是清空颜色缓冲区color

    gl.drawArrays(gl.POINTS, 0, 1);
}
#+end_src
** 例子： 在鼠标点击位置绘制点，使用attribute变量传递鼠标点击位置给顶点着色器；用uniform变量传递颜色给片元着色器
#+begin_src javascript
// Vertex shader program
var VSHADER_SOURCE =
    'attribute vec4 a_Position;\n' + //  声明attribute 变量
    'void main() {\n' +
    '  gl_Position = a_Position;\n' +
    '  gl_PointSize = 10.0;\n' +
    '}\n';

// Fragment shader program
var FSHADER_SOURCE =
    'precision mediump float;\n' +
    'uniform vec4 u_FragColor;\n' +  // 声明uniform变量。 顶点着色器才能使用attribute变量， 如果想从app传递数据给片元着色器，就要使用uniform变量。
    'void main() {\n' +
    '  gl_FragColor = u_FragColor;\n' +
    '}\n';

function main() {
    var canvas = document.getElementById('webgl');

    var gl = getWebGLContext(canvas);
    if (!gl) {
        console.log('Failed to get the rendering context for WebGL');
        return;
    }

    if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
        console.log('Failed to intialize shaders.');
        return;
    }

    var a_Position = gl.getAttribLocation(gl.program, 'a_Position'); // 获取attribute变量的存储位置
    if (a_Position < 0) {
        console.log('Failed to get the storage location of a_Position');
        return;
    }

    var u_FragColor = gl.getUniformLocation(gl.program, 'u_FragColor'); // 获取uniform变量的存储位置
    if (!u_FragColor) {
        console.log('Failed to get the storage location of u_FragColor');
        return;
    }

    canvas.onmousedown = function(ev){ click(ev, gl, canvas, a_Position, u_FragColor) }; // 注册鼠标点击时的回调函数

    gl.clearColor(0.0, 0.0, 0.0, 1.0);

    gl.clear(gl.COLOR_BUFFER_BIT);     // 用上面设置的clearColor清空绘图区域。opengl有多个缓冲区：颜色缓冲区COLOR_BUFFER_BIT、深度缓冲区DEPTH_BUFFER_BIT、模版缓冲区STENCIL_BUFFER_BIT。清空绘图区域实际上是清空颜色缓冲区color
}

var g_points = [];  // 记录所有鼠标点击位置的坐标
var g_colors = [];  // The array to store the color of a point
function click(ev, gl, canvas, a_Position, u_FragColor) {
    var x = ev.clientX;   //  鼠标点击位置的坐标，是一个基于浏览器客户区的坐标值（client area）
    var y = ev.clientY;   //  下面还要做坐标转换：client area  --》 canvas坐标  --》 webgl的归一化设备坐标
    var rect = ev.target.getBoundingClientRect(); // 获取canvas的矩形区域

    // （x - rect.left）从浏览器客户区坐标转换成canvas坐标。  ((x - rect.left) - canvas.width/2) 获得把canvas的原点移到中心点的坐标。 再除以(canvas.width/2）完成归一化。
    x = ((x - rect.left) - canvas.width/2)/(canvas.width/2); // 把鼠标点击时的坐标转换为opengl的归一化坐标（-1.0，1.0）
    y = (canvas.height/2 - (y - rect.top))/(canvas.height/2); // (y - rect.top) 从浏览器客户区坐标转换成canvas坐标。 (canvas.height/2 - (y - rect.top))获得把canvas的原点移到中心点的坐标

    g_points.push([x, y]);                 // 要把鼠标每次点击的位置都记录下来（基于webgl的归一化的坐标）？而不是仅仅记录最近一次鼠标点击的位置。

    if (x >= 0.0 && y >= 0.0) {      // 不同的区域设置不同的颜色， 第一象限
        g_colors.push([1.0, 0.0, 0.0, 1.0]);  // Red
    } else if (x < 0.0 && y < 0.0) { // 第三象限
        g_colors.push([0.0, 1.0, 0.0, 1.0]);  // Green
    } else {                         // 其它
        g_colors.push([1.0, 1.0, 1.0, 1.0]);  // White
    }

    gl.clear(gl.COLOR_BUFFER_BIT); //  这行很重要。每次绘制完成之后，颜色缓冲区都会被重置，所以这里要明确的用我们自己设定的clear color来清空画布。

    var len = g_points.length;      // 绘制操作实际上是在颜色缓冲区color buffer中进行，绘制结束后系统将缓冲区中的内容显示在屏幕上，然后颜色缓冲区就会被重置，其中的内容会丢失
    for(var i = 0; i < len; i++) {  // 因此我们有必要将鼠标每次点击的位置都记录下来，鼠标每次点击之后，程序都重新绘制了所有的点，从第一次点击到最近的一次。
        var xy = g_points[i];         // 比如第1次点击鼠标，绘制第1个点；。。。 第3次点击鼠标，绘制第1、2和第3个点；以此类推
        var rgba = g_colors[i];

        gl.vertexAttrib3f(a_Position, xy[0], xy[1], 0.0); // 通过赋值给attribute变量， 把值传递给着色器
        gl.uniform4f(u_FragColor, rgba[0], rgba[1], rgba[2], rgba[3]); // 通过赋值给uniform变量，把颜色值传递给片元着色器的内置变量 u_FragColor
        gl.drawArrays(gl.POINTS, 0, 1);                                // 触发绘制
    }
}
#+end_src


* 缓冲对象buffer object
- 可以预先在缓冲对象中保存所有想要绘制的顶点数据，然后一次性的向着色器传入多个顶点的数据，避免多次传输，提高效率。需要5个步骤：
  1) 创建缓冲区对象 vertexBuffer = gl.createBuffer()
  2) 绑定缓冲区对象到目标区域 gl.bindBuffer(gl.ARRAY_BUFFER | gl.ELEMENT_ARRAY_BUFFER, vertexBuffer)。
     - 目标区域gl.ARRAY_BUFFER表示缓冲区对象中包含的是顶点的数据。 gl.ELEMENT_ARRAY_BUFFER表示缓冲区对象中包含了顶点的索引值
  3) 向缓冲区对象写入数据 gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW) 将第2个参数vertices中的数据写入目标区域gl.ARRAY_BUFFER所对应的缓冲区（其实就是上一步绑定的缓冲区）
     - GL_STATIC_DRAW：表示该缓存区不会被修改； GL_DyNAMIC_DRAW：表示该缓存区会被周期性更改；GL_STREAM_DRAW：表示该缓存区会被频繁更改；
  4) 将缓冲区对象分配给一个attribute 变量 gl.vertexAttribPointer
  5) 开启attribute变量 gl.enableVertexAttribArray
