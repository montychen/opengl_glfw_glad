* 入门
** OpenGL
- 早期的OpenGL使用 *立即渲染模式* （Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少能控制OpenGL如何进行计算的自由。
- *立即渲染模式* 确实容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的 *核心模式* ( *Core-profile* )下进行开发，3.3分支的规范完全移除了旧的特性。后续OpenGL的更高的版本都是在3.3的基础上，引入了额外的功能，并没有改动核心架构。
  #+begin_src c++
glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 明确告诉GLFW我们使用的是核心模式(Core-profile
glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // 如果使用的是Mac系统，需要这行代码；mac默认使用的是比较旧的版本，这行强制系统使用当前硬件支持的最新版本。
  #+end_src
  - 当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图。现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。

** 状态机
- OpenGL自身是一个巨大的 *状态机(State Machine)* ，整个绘制操作会按照图形管线的固定流程进行，如同一条流水线。OpenGL函数只是用来设置这条流水线的
  一些参数状态，并不是用来真正执行绘制操作的。 OpenGL的状态通常被称为 *上下文(Context)* 。假设我们想画线段而不是三角形的时候，可以通过OpenGL的函数
  调用来改变上下文状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。
  
- 在OpenGL中一个 *Object对象* 是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体Struct。
  #+begin_src c++
// 创建 *对象* , 然后用一个id保存它的引用
unsigned int objectId = 0;
glGenObject(1, &objectId);

// 将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）
glBindObject(GL_WINDOW_TARGET, objectId);

// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 6500);
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);

// 将目标位置的对象id设回0，解绑这个对象。将上下文对象设回默认.
// 设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。
glBindObject(GL_WINDOW_TARGET, 0);
  #+end_src
  - 使用对象的一个好处是在程序中，我们不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。在我们执行一个使用OpenGL状态的操作的时候，只需要绑定含有需要的设置的对象即可。比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了（当然，我们需要先创建并设置对象的选项）。

* 图形管线 PipeLine

** 图形管线的3个阶段: 应用、几何、光栅
#+ATTR_latex: :width 650   #+ATTR_HTML: :width 6500  #+ATTR_ORG: :width 6500
[[file:OpenGL/pipeline_3stage.jpg]]

#+ATTR_latex: :width 650   #+ATTR_HTML: :width 6500  #+ATTR_ORG: :width 6500
[[file:OpenGL/pipeline_3stage_all.jpg]]

#+ATTR_latex: :width 650   #+ATTR_HTML: :width 6500  #+ATTR_ORG: :width 6500
[[file:OpenGL/pipeline_3stage_2.jpg]]

** 图形管线分工
#+ATTR_latex: :width 650   #+ATTR_HTML: :width 6500  #+ATTR_ORG: :width 6500
[[file:OpenGL/pipeline1.png]]

#+ATTR_latex: :width 650   #+ATTR_HTML: :width 6500  #+ATTR_ORG: :width 6500
[[file:OpenGL/pipeline.png]]


** GLSL和OpenGL的通信
*** uniform、inout
*Uniform* 是一种从CPU应用向GPU着色器发送数据的一种方式。Uniform是全局的，在某一着色器里声明了它，其他着色器就可以使用它。
#+ATTR_latex: :width 650   #+ATTR_HTML: :width 6500  #+ATTR_ORG: :width 6500
[[file:OpenGL/glsl_opengl.jpg]]

*** VBO & VAO & EBO
*VBO* (顶点缓冲对象：Vertex Buffer Object)是显卡高速显存的缓冲区，用来保存顶点的信息。 顶点缓冲对象VBO是在显卡存储空间中开辟出的一块内存缓存区，
用于存储顶点的各类属性信息，如顶点坐标，顶点法向量，顶点颜色数据等。在渲染时，可以直接从VBO中取出顶点的各类属性数据，由于VBO在显存而不是在内存中，
不需要从CPU传输数据，处理效率更高。

*VAO* (顶点数组对象Vertex Array Object) 保存了所有顶点数据属性的状态结合，VAO本身并没有存储顶点的相关属性数据，这些信息是存储在VBO中的，
VAO相当于是对很多个VBO的引用，把一些VBO组合在一起作为一个对象统一管理。

*EBO* (索引缓冲对象：Element Buffer Object)也是一个缓冲，它专门储存顶点的索引，是为了解决同一顶点重复调用的问题，可以减少内存浪费提高执行效率。
当需要使用重复顶点的时候，可以通过顶点索引来调用顶点，而不是重复记录。

** 光栅化 Rasterization
一定要牢记，显示屏是二维的，GPU 所需要做的是将三维的数据，绘制到二维屏幕上。*光栅化* 就是将一个几何图元转变为屏幕栅格上的二维图像的过程，这个二维图像由光栅上离散的点阵构成，每个点都包含了 *颜色、深度和纹理* 数据。将该点和相关信息叫做一个 *片元（fragment）* 。 粗略地讲：根据图形的定义的那些顶点在经过各种矩阵变换后也仅仅是顶点。而由顶点构成的三角形要在屏幕上显示出来，除了需要三个顶点的信息以外，还需要确定这个三角形内部的所有像素的信息。光栅化就是干这个的。主要有2步：
1. 在栅格点阵上找出最佳逼近于图形(比如三角形）的像素集。逼近的过程本质可以认为是： *连续量向离散量的转换* 。
2. 给像素指定合适的颜色值，包括插值出三角形内部所有点的属性值（Z值、颜色、法向、纹理坐标等）。可以通过光照、纹理的计算，来确定像素的颜色值。
   #+ATTR_latex: :width 650   #+ATTR_HTML: :width 6500  #+ATTR_ORG: :width 6500
[[file:OpenGL/rasterization.png]]



* 变换 Transformation: 几何变换 -> 投影 -> 裁剪 -> 视口变换
*MVP* 几何单元（比如三角形）在经过: M模型矩阵变换、V视角矩阵变换、P投影矩阵变化以及透视除法后，坐标都变换到归一化的NDC坐标系下[-1， 1] 。在知道输出屏幕大小的情况下，通过视口变换可将x/y变换到窗口大小下（x∈【0，width】 y∈【0，height】z不变）。至此我们即将所有三角形投射到raster_space中。

#+ATTR_latex: :width 700   #+ATTR_HTML: :width 700  #+ATTR_ORG: :width 700
[[file:OpenGL/MVP.jpg]]

** 几何变换：通过旋转、平移、缩放来调整后位置
** 投影: 裁剪clipping(frustum culling视椎体剔除) + 透视除法生成NDC。
*投影矩阵(projection matrix)* :显示器是二维的, 一个3D场景需要被投影到屏幕上成为一个2D图像，这称为投影变换，需要用到投影矩阵，投影干两件事:
1. 投影矩阵会创建一个视椎体对物体坐标进行 *裁剪clipping(即frustum culling视椎体剔除)* 。实现方式就是投影矩阵先把顶点坐标从eye coordinates观察空间变换到裁剪坐标clip coordinate, 然后再把视椎体外不可见的部分裁剪掉 。
2. *裁剪坐标再通过透视除法被变换到标准化设备坐标NDC* ，这一步是用裁剪坐标的w分量除裁剪坐标(x/w, y/w, z/w, w/w)实现的。

*** 视锥体frustum、裁剪坐标clipping coordinates
不管是正交投影orthographic还是透视投影，最终都是将视景体内的物体投影在近平面上，这也是 3D 坐标转换到 2D 坐标的关键一步。 在用opengl绘制一张图片的时候经常会遇到图片被拉伸的问题，为了解决该问题，关键就是让近平面的宽高比和视口宽高比保持一致，并且以较短的一边作为 1 的标准，让图像保持居中。
- 视锥体（frustum），它包含六个平面（近平面、远平面、上平面、下平面、右平面和左平面）
- 裁剪坐标（clipping coordinates）：位于这个视锥体以外的顶点都会被剪裁掉，所得的坐标结果成为裁剪坐标（clipping coordinates）
- 视锥体的形状决定了3D到2D的投影类型，如果近平面和远平面尺寸一致，那么物体上的顶点不论远近都以统一的方式投影在屏幕上，这是正交投影orthographic projection。否则就是透视投影perspective projection。简单来说， *透视投影有近大远小的效果* ，而正交投影没有。
#+ATTR_latex: :width 500   #+ATTR_HTML: :width 500  #+ATTR_ORG: :width 500
[[file:webgl/frustum.png]]


** 裁剪: 把视椎体外不可见的部分裁剪掉
** 视口变换：显示在电脑窗口的上
** 齐次坐标 & 列主序矩阵 & 单位矩阵
*** 齐次坐标（Homogeneous coordinates）: 能用 左乘矩阵 来统一完成所有的坐标变换

*齐次坐标*  就是将一个原本是n维的向量用n+1维来表示。 比如，三维中的点（x, y, z）表示成 （x, y, z, w）。

齐次坐标的作用：能够统一使用 *左乘矩阵* 来完成所有的坐标变换：平移、缩放、旋转、错切(表示弹性物体的变形）、对称、投影。没有w分量矩阵运算实现不了平移.
*左乘矩阵* : 指的是矩阵和顶点相乘时，矩阵放在左边，如: 矩阵 x 顶点 = 变换后的顶点.

那么，统一使用矩阵来完成坐标变换的有哪些好处？
- GPU的设计天然就更适合矩阵运算。
- 更重要的是，矩阵可以通过相乘，来进行可以组合，也就是把多个连续的变换矩阵组合成一个矩阵，这样可以大大提高效率。


想要从齐次向量得到3D向量，我们可以把x、y和z坐标分别除以w坐标。我们通常不会注意这个问题，因为w分量通常是1.0。
- 若w==1，则向量(x, y, z, 1）表示的是空间中的点。
- 若w==0，则向量(x, y, z, 0) 表示的是方向。 此时，这个向量就不能位移，”平移一个方向”是毫无意义的。

*** OpenGL API接受的矩阵要求是 *列主序*
在实际编程语言中，我们使用的一维数组来存储4x4矩阵的16个元素。所谓的行存储和列存储的区分就在于数组的前四个元素存储的是矩阵的第一列还是第一行；表示列的称为列存储，表示行的成为行存储。
#+ATTR_latex: :width 800   #+ATTR_HTML: :width 800  #+ATTR_ORG: :width 800
[[file:webgl/column_order.png]]

*** 单位矩阵(Identity Matrix): 主对角线元素为1，其余元素为0, 可简记为I。
在c++，用glm构造一个单位矩阵 glm::mat4(1.0);
#+begin_src c++
glm::mat4 myIdentityMatrix = glm::mat4(1.0);
#+end_src
#+ATTR_latex: :width 400   #+ATTR_HTML: :width 400  #+ATTR_ORG: :width 400
[[file:webgl/identity_matrix.png]]


* 坐标&旋转
** OpenGL坐标
*OpenGL使用右手坐标系* ： 伸开右手，大拇指指向X轴正方向，食指指向Y轴正方向，其他三个手指指向Z轴正方向。

原点（0.0，0.0，0.0）在屏幕的中间，X轴正向朝右， Y轴正向朝上，Z轴垂直于屏幕正向朝外（从屏幕指向你的后面）；看向屏幕， 视线方向是Z轴的负方向。

#+ATTR_latex: :width 700   #+ATTR_HTML: :width 700  #+ATTR_ORG: :width 700
[[file:webgl/webgl_coord.png]]

** 纹理坐标texture coordinates：纹理通常来说就是一张图片
- 纹理坐标：原点（0.0， 0.0）在左下角，  x轴正向朝右， y轴正向朝上。坐标值和图像大小无关，不管是128*128还是128*256的图像，其右上角坐标始终是（1.0，1.0）
- 纹理坐标就是纹理图像上的坐标，纹理坐标是二维的，为了和广泛使用的xy坐标区分开来， 习惯用s和t来命名纹理坐标（st坐标系统）。
- 不论图片尺寸有多大，长和宽各是多少，强制规定了纹理坐标总是从0到1之间取值。
- 通过纹理坐标可以在纹理图像上获取纹素的颜色。

#+ATTR_latex: :width 400   #+ATTR_HTML: :width 400  #+ATTR_ORG: :width 400
[[file:webgl/texture_coord.png]]

** R旋转 Rotate
在OpenGL的右手坐标系下，旋转规则是： 确定旋转轴后，右手握成拳头，拇指指向旋转轴的正方向，其余手指的弯曲方向即为旋转的正方向，跟手指弯曲方向一致的
旋转记为正向，相反则为负向。例如： Z轴正旋转或者Z轴逆时针旋转，就是大拇指指向Z轴，其余手指弯曲的方向就是Z轴旋转正方向。这个正方向，其实是逆时针
方向，所以一般规定逆时针为正就是这么来的，也就是说，旋转方向可以用旋转角度值的正负来表示。

为了描述旋转（比如：绕Z轴，逆时针旋转了β角度），必须指明3个要素：
- 旋转轴（图像将围绕旋转轴旋转）
- 转转角度（图形旋转经过的角度）
- 旋转方向（顺时针or逆时针）： 在调用旋转函数时，一般不会传入一个表示旋转方向的参数。因为如果旋转的角度是正值，那就是逆时针旋转，原因如上所述。

#+ATTR_latex: :width 300   #+ATTR_HTML: :width 300  #+ATTR_ORG: :width 300
[[file:webgl/z_rotation.png]]

* OpenGL函数
** glLoadIdentity()，glPushMatrix()，glPopMatrix()
- glLoadIdentity()的作用就是把当前矩阵设为为单位矩阵.
- glPushMatrix、glPopMatrix相当于堆栈里的入栈和出栈。 *Push起到保护环境、Pop起到恢复环境的作用* 。这2个函数可以嵌套使用。调用glPushMatrix就是把 当前矩阵做一个副本放入堆栈，然后不管你之后做了多少变换，这时调用glPopMatrix，当前矩阵就可以恢复到你调用glPushMatrix之前的那个状态。例如当前的 坐标系原点在电脑屏幕的左上方。现在调用glPushMatrix，然后再调用一堆平移、旋转代码等等，然后再画图。那些平移和旋转都是基于坐上角为原点进行变化的。 而且都会改变坐标的位置，经过了这些变化后，你的坐标肯定不再左上角了。如果想恢复怎么办？这时调用glPopMatrix从栈里取出一个“状态”，这个状态就是 你调用glPushMatrix之前的那个状态。
** glMatrixMode(GLenum mode); 设置当前矩阵是什么矩阵：
OpenGL里面的操作，很多是对矩阵的操作，比如位移，旋转，缩放。glMatrixMode就是用来指定接下来将要对那类矩阵进行操作，由参数mode来指定
- GL_MODELVIEW对模型视景矩阵操作: 接下来的语句描绘一个以模型为基础的适应，这样来设置参数，接下来用到的就是像gluLookAt()这样的函数
- GL_PROJECTION对投影矩阵操作: 就像照相一样，把3维物体投到2维平面上。这样，接下来的语句可以是跟透视相关的函数，如glFrustum()或gluPerspective()
- GL_TEXTURE是对纹理矩阵进行随后的操作

当我们设置了当前的矩阵后，接下来调用的openGL库函数必须确定是针对我们设定的这个当前矩阵的，不能张冠李戴。 例如，下面这样调用是错误的， 因为我们设置了 当前矩阵为模型视景矩阵，而gluPerspective是要对投影矩阵进行操作，那么计算机就会把模型矩阵当做投影矩阵，来与 gluPerspective指定的矩阵进行乘法运算，最终导致错误。
#+begin_src c++
glMatrixMode（GL_MODELVIEW ）；//设置当前矩阵为模型视景矩阵
gluPerspective(45.0f, (GLfloat)cx/(GLfloat)cy, 0.1f, 100.0f)；  //对图像进行透视投影，以将三维物体显示在二维平面上

#+end_src
