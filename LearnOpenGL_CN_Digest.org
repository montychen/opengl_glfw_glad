* 入门
** OpenGL
- 早期的OpenGL使用 *立即渲染模式* （Immediate mode，也就是固定渲染管线），这个模式下绘制图形很方便。OpenGL的大多数功能都被库隐藏起来，开发者很少能控制OpenGL如何进行计算的自由。
- *立即渲染模式* 确实容易使用和理解，但是效率太低。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的 *核心模式* ( *Core-profile* )下进行开发，3.3分支的规范完全移除了旧的特性。后续OpenGL的更高的版本都是在3.3的基础上，引入了额外的功能，并没有改动核心架构。
  #+begin_src c++
glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 明确告诉GLFW我们使用的是核心模式(Core-profile
glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // 如果使用的是Mac系统，需要这行代码；mac默认使用的是比较旧的版本，这行强制系统使用当前硬件支持的最新版本。
  #+end_src
  - 当使用OpenGL的核心模式时，OpenGL迫使我们使用现代的函数。当我们试图使用一个已废弃的函数时，OpenGL会抛出一个错误并终止绘图。现代函数要求使用者真正理解OpenGL和图形编程，它有一些难度，然而提供了更多的灵活性，更高的效率，更重要的是可以更深入的理解图形编程。

** 状态机
- OpenGL自身是一个巨大的 *状态机(State Machine)* ：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为 *上下文(Context)* 。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。
- 在OpenGL中一个 *Object对象* 是指一些选项的集合，它代表OpenGL状态的一个子集。比如，我们可以用一个对象来代表绘图窗口的设置，之后我们就可以设置它的大小、支持的颜色位数等等。可以把对象看做一个C风格的结构体Struct。
  #+begin_src c++
// 创建 *对象* , 然后用一个id保存它的引用
unsigned int objectId = 0;
glGenObject(1, &objectId);

// 将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成GL_WINDOW_TARGET）
glBindObject(GL_WINDOW_TARGET, objectId);

// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, 6500);
glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, 600);

// 将目标位置的对象id设回0，解绑这个对象。将上下文对象设回默认.
// 设置的选项将被保存在objectId所引用的对象中，一旦我们重新绑定这个对象到GL_WINDOW_TARGET位置，这些选项就会重新生效。
glBindObject(GL_WINDOW_TARGET, 0);
  #+end_src
  - 使用对象的一个好处是在程序中，我们不止可以定义一个对象，并设置它们的选项，每个对象都可以是不同的设置。在我们执行一个使用OpenGL状态的操作的时候，只需要绑定含有需要的设置的对象即可。比如说我们有一些作为3D模型数据（一栋房子或一个人物）的容器对象，在我们想绘制其中任何一个模型的时候，只需绑定一个包含对应模型数据的对象就可以了（当然，我们需要先创建并设置对象的选项）。

* 图形管线 PipeLine

** 图形管线的3个阶段: 应用、几何、光栅
#+ATTR_latex: :width 650   #+ATTR_HTML: :width 6500  #+ATTR_ORG: :width 6500
[[file:OpenGL/pipeline_3stage.jpg]]

#+ATTR_latex: :width 650   #+ATTR_HTML: :width 6500  #+ATTR_ORG: :width 6500
[[file:OpenGL/pipeline_3stage_all.jpg]]

#+ATTR_latex: :width 650   #+ATTR_HTML: :width 6500  #+ATTR_ORG: :width 6500
[[file:OpenGL/pipeline_3stage_2.jpg]]

** 图形管线分工
#+ATTR_latex: :width 650   #+ATTR_HTML: :width 6500  #+ATTR_ORG: :width 6500
[[file:OpenGL/pipeline.png]]


#+ATTR_latex: :width 650   #+ATTR_HTML: :width 6500  #+ATTR_ORG: :width 6500
[[file:OpenGL/pipeline1.png]]

** GLSL和OpenGL的通信
*** uniform、inout
*Uniform* 是一种从CPU应用向GPU着色器发送数据的一种方式。Uniform是全局的，在某一着色器里声明了它，其他着色器就可以使用它。
#+ATTR_latex: :width 650   #+ATTR_HTML: :width 6500  #+ATTR_ORG: :width 6500
[[file:OpenGL/glsl_opengl.jpg]]

*** VBO & VAO & EBO
*VBO* (顶点缓冲对象：Vertex Buffer Object)是显卡高速显存的缓冲区，用来保存顶点的信息。 顶点缓冲对象VBO是在显卡存储空间中开辟出的一块内存缓存区，
用于存储顶点的各类属性信息，如顶点坐标，顶点法向量，顶点颜色数据等。在渲染时，可以直接从VBO中取出顶点的各类属性数据，由于VBO在显存而不是在内存中，
不需要从CPU传输数据，处理效率更高。

*VAO* (顶点数组对象Vertex Array Object) 保存了所有顶点数据属性的状态结合，VAO本身并没有存储顶点的相关属性数据，这些信息是存储在VBO中的，
VAO相当于是对很多个VBO的引用，把一些VBO组合在一起作为一个对象统一管理。

*EBO* (索引缓冲对象：Element Buffer Object)也是一个缓冲，它专门储存顶点的索引，是为了解决同一顶点重复调用的问题，可以减少内存浪费提高执行效率。
当需要使用重复顶点的时候，可以通过顶点索引来调用顶点，而不是重复记录。

** 光栅化 Rasterization
*光栅化* 就是将一个几何图元转变为栅格上的二维图像的过程，这个二维图像由光栅上离散的点阵构成，每个点都包含了 *颜色、深度和纹理* 数据。
将该点和相关信息叫做一个 *片元（fragment）* 。

光栅化的目的，是找出一个几何单元（比如三角形）所覆盖的所有像素。粗略地讲：你模型的那些顶点在经过各种矩阵变换后也仅仅是顶点。而由顶点构成的三角形
要在屏幕上显示出来，除了需要三个顶点的信息以外，还需要确定构成这个三角形的所有像素的信息。光栅化就是干这个的。主要有2步：
- 第一步： 根据图形的定义，在栅格点阵单元上找到最佳逼近于图形的像素集。逼近的过程本质可以认为是：连续量向离散量的转换。
- 第二笔：给像素指定合适的颜色值。可以通过光照、纹理的计算，来确定像素的颜色值。
  #+ATTR_latex: :width 650   #+ATTR_HTML: :width 6500  #+ATTR_ORG: :width 6500
[[file:OpenGL/rasterization.png]]
